import { query } from './database';
import { AlertEvent } from '../alerts/alertManager';

export class AlertStorageDB {
  private async recordResolutionEvent(
    alertId: string,
    data: {
      actionType: string;
      actor?: string;
      notes?: string;
      reasonCode?: string;
      reasonLabel?: string;
      closureType?: string;
      documentUrl?: string;
      documentName?: string;
      documentType?: string;
      payload?: Record<string, any>;
    }
  ): Promise<void> {
    await query(
      `INSERT INTO alert_resolution_events
       (alert_id, action_type, actor, notes, reason_code, reason_label, closure_type, document_url, document_name, document_type, payload)
       VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11)`,
      [
        alertId,
        data.actionType,
        data.actor || null,
        data.notes || null,
        data.reasonCode || null,
        data.reasonLabel || null,
        data.closureType || null,
        data.documentUrl || null,
        data.documentName || null,
        data.documentType || null,
        JSON.stringify(data.payload || {})
      ]
    );
  }

  async closeAlertWithDetails(input: {
    alertId: string;
    closureType: 'resolved' | 'false_alert' | 'ncr' | 'report';
    notes: string;
    actor?: string;
    reasonCode?: string;
    reasonLabel?: string;
    documentUrl?: string;
    documentName?: string;
    documentType?: string;
    payload?: Record<string, any>;
  }): Promise<boolean> {
    const closureSubtype =
      input.closureType === 'resolved' ? 'manual' : input.closureType;
    const isFalse = input.closureType === 'false_alert';

    const result = await query(
      `UPDATE alerts
       SET status = 'resolved',
           resolved = TRUE,
           resolved_at = NOW(),
           resolution_notes = $1,
           resolved_by = $2,
           closure_type = $3,
           closure_subtype = $4,
           resolution_reason_code = $5,
           resolution_reason_label = $6,
           is_false_alert = $7,
           false_alert_reason = CASE WHEN $7 THEN $1 ELSE false_alert_reason END,
           false_alert_reason_code = CASE WHEN $7 THEN $5 ELSE false_alert_reason_code END,
           ncr_document_url = CASE WHEN $3 = 'ncr' THEN $8 ELSE ncr_document_url END,
           ncr_document_name = CASE WHEN $3 = 'ncr' THEN $9 ELSE ncr_document_name END,
           report_document_url = CASE WHEN $3 = 'report' THEN $8 ELSE report_document_url END,
           report_document_name = CASE WHEN $3 = 'report' THEN $9 ELSE report_document_name END,
           report_document_type = CASE WHEN $3 = 'report' THEN $10 ELSE report_document_type END,
           closure_payload = COALESCE($11::jsonb, '{}'::jsonb)
       WHERE id = $12`,
      [
        input.notes,
        input.actor || null,
        input.closureType === 'resolved' ? 'manual' : input.closureType,
        closureSubtype,
        input.reasonCode || null,
        input.reasonLabel || null,
        isFalse,
        input.documentUrl || null,
        input.documentName || null,
        input.documentType || null,
        JSON.stringify(input.payload || {}),
        input.alertId
      ]
    );

    const ok = (result.rowCount || 0) > 0;
    if (ok) {
      await this.recordResolutionEvent(input.alertId, {
        actionType: input.closureType === 'resolved' ? 'resolved' : input.closureType,
        actor: input.actor,
        notes: input.notes,
        reasonCode: input.reasonCode,
        reasonLabel: input.reasonLabel,
        closureType: input.closureType,
        documentUrl: input.documentUrl,
        documentName: input.documentName,
        documentType: input.documentType,
        payload: input.payload
      });
    }
    return ok;
  }

  async saveAlert(alert: AlertEvent) {
    await query(
      `INSERT INTO alerts (id, device_id, channel, alert_type, priority, status, resolved, escalation_level, timestamp, latitude, longitude, metadata)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
       ON CONFLICT (id) DO UPDATE SET
         status = EXCLUDED.status,
         resolved = EXCLUDED.resolved,
         escalation_level = EXCLUDED.escalation_level,
         acknowledged_at = EXCLUDED.acknowledged_at,
         resolved_at = EXCLUDED.resolved_at,
         metadata = EXCLUDED.metadata`,
      [
        alert.id,
        alert.vehicleId,
        alert.channel,
        alert.type,
        alert.priority,
        alert.status,
        alert.status === 'resolved',
        alert.escalationLevel,
        alert.timestamp,
        alert.location.latitude,
        alert.location.longitude,
        JSON.stringify(alert.metadata)
      ]
    );
  }

  async updateAlertStatus(alertId: string, status: string, acknowledgedAt?: Date, resolvedAt?: Date, notes?: string, resolvedBy?: string) {
    await query(
      `UPDATE alerts
       SET status = $1,
           resolved = CASE WHEN $1 = 'resolved' THEN TRUE ELSE FALSE END,
           acknowledged_at = $2,
           resolved_at = $3,
           resolution_notes = $4,
           resolved_by = $5
       WHERE id = $6`,
      [status, acknowledgedAt, resolvedAt, notes, resolvedBy, alertId]
    );
  }

  async resolveWithNcr(
    alertId: string,
    notes: string,
    resolvedBy?: string,
    ncrDocumentUrl?: string,
    ncrDocumentName?: string
  ): Promise<boolean> {
    return this.closeAlertWithDetails({
      alertId,
      closureType: 'ncr',
      notes,
      actor: resolvedBy,
      documentUrl: ncrDocumentUrl,
      documentName: ncrDocumentName,
      documentType: 'ncr'
    });
  }

  async markAsFalseAlert(
    alertId: string,
    reason: string,
    markedBy?: string,
    reasonCode?: string
  ): Promise<boolean> {
    return this.closeAlertWithDetails({
      alertId,
      closureType: 'false_alert',
      notes: reason,
      actor: markedBy,
      reasonCode,
      reasonLabel: reason
    });
  }

  async getUnattendedAlerts(minutesThreshold: number = 30) {
    const cutoff = new Date(Date.now() - minutesThreshold * 60000);
    const result = await query(
      `SELECT * FROM alerts 
       WHERE status = 'new' AND timestamp < $1 
       ORDER BY priority DESC, timestamp ASC`,
      [cutoff]
    );
    return result.rows;
  }

  async getActiveAlerts() {
    const result = await query(
      `SELECT * FROM alerts WHERE status IN ('new', 'escalated', 'acknowledged') ORDER BY timestamp DESC`
    );
    return result.rows;
  }

  async getAlertById(alertId: string) {
    const result = await query(`SELECT * FROM alerts WHERE id = $1`, [alertId]);
    return result.rows[0];
  }

  async getAlertWithVideos(alertId: string) {
    const result = await query(
      `SELECT a.*,
         (SELECT file_path FROM videos WHERE alert_id = a.id AND video_type = 'alert_pre') as pre_video_path,
         (SELECT file_path FROM videos WHERE alert_id = a.id AND video_type = 'alert_post') as post_video_path
       FROM alerts a WHERE a.id = $1`,
      [alertId]
    );
    return result.rows[0];
  }
}
