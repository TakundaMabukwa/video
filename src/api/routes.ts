import express from 'express';
import { JTT808Server } from '../tcp/server';
import { UDPRTPServer } from '../udp/server';
import { SpeedingManager } from '../services/speedingManager';
import { VideoStorage } from '../storage/videoStorage';
import * as path from 'path';
import * as fs from 'fs';
import * as crypto from 'crypto';
import { spawn } from 'child_process';
import { query as dbQuery } from '../storage/database';

export function createRoutes(tcpServer: JTT808Server, udpServer: UDPRTPServer): express.Router {
  const router = express.Router();
  const speedingManager = new SpeedingManager();
  const videoStorage = new VideoStorage();
  const manualVideoJobs = new Map<string, {
    id: string;
    vehicleId: string;
    channel: number;
    startTime: string;
    endTime: string;
    alertId?: string;
    windowType?: 'pre' | 'post';
    status: 'queued' | 'running' | 'completed' | 'failed';
    createdAt: string;
    updatedAt: string;
    outputPath?: string;
    outputUrl?: string;
    persistedVideoId?: string;
    persistedVideoUrl?: string;
    error?: string;
  }>();
  const queuedAlertWindows = new Set<string>();
  const buildAlertMediaLinks = (alertId: string) => {
    const id = encodeURIComponent(String(alertId));
    return {
      alert: `/api/alerts/${id}`,
      videos: `/api/alerts/${id}/videos`,
      preVideo: `/api/alerts/${id}/video/pre`,
      postVideo: `/api/alerts/${id}/video/post`,
      requestReportVideo: `/api/alerts/${id}/request-report-video`
    };
  };
  const withAlertMediaLinks = (alert: any) => ({
    ...alert,
    mediaLinks: buildAlertMediaLinks(alert.id)
  });
  const parseResourceTime = (value: string): Date | null => {
    if (!value || typeof value !== 'string') return null;
    const isoLike = value.replace(' ', 'T');
    const d = new Date(isoLike);
    if (!Number.isNaN(d.getTime())) return d;
    const dUtc = new Date(`${isoLike}Z`);
    return Number.isNaN(dUtc.getTime()) ? null : dUtc;
  };
  const normalizePublicVideoUrl = (value: any, fallback: string) => {
    const s = String(value || '').trim();
    if (s && /^https?:\/\//i.test(s)) return s;
    if (s && s.startsWith('/api/')) return s;
    return fallback;
  };
  const transcodeCache = new Map<string, Promise<string>>();
  const getFfmpegBinary = () => {
    if (process.env.FFMPEG_PATH) return process.env.FFMPEG_PATH;
    try {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const installer = require('@ffmpeg-installer/ffmpeg');
      if (installer?.path) return installer.path;
    } catch {}
    return 'ffmpeg';
  };
  const runFfmpegProfiles = async (profiles: string[][], outputPath: string) => {
    let lastError = 'ffmpeg failed';
    for (const args of profiles) {
      try {
        await new Promise<void>((resolve, reject) => {
          const ffmpeg = spawn(getFfmpegBinary(), args, { stdio: ['ignore', 'ignore', 'pipe'] });
          let stderr = '';
          ffmpeg.stderr.on('data', (d) => { stderr += String(d || ''); });
          ffmpeg.on('error', (err) => reject(new Error(err?.message || 'Failed to spawn ffmpeg')));
          ffmpeg.on('close', (code) => {
            if (code === 0 && fs.existsSync(outputPath) && fs.statSync(outputPath).size > 0) {
              resolve();
              return;
            }
            try {
              if (fs.existsSync(outputPath)) fs.unlinkSync(outputPath);
            } catch {}
            reject(new Error(stderr?.slice(0, 800) || `ffmpeg exited with code ${code}`));
          });
        });
        return;
      } catch (err: any) {
        lastError = err?.message || String(err);
      }
    }
    throw new Error(lastError);
  };
  const toPlayableMp4 = async (sourcePath: string, inputFpsHint?: number) => {
    if (!sourcePath) throw new Error('Missing source file');
    if (!fs.existsSync(sourcePath)) throw new Error(`Source file not found: ${sourcePath}`);
    if (/\.mp4$/i.test(sourcePath)) return sourcePath;

    const safeInputFps = Number.isFinite(Number(inputFpsHint)) && Number(inputFpsHint) > 0
      ? Math.max(0.2, Math.min(30, Number(inputFpsHint)))
      : null;
    const parsed = path.parse(sourcePath);
    const fpsTag = safeInputFps ? `.fps${String(safeInputFps).replace('.', '_')}` : '';
    const outputPath = path.join(parsed.dir, `${parsed.name}${fpsTag}.playable.mp4`);
    const sourceStat = fs.statSync(sourcePath);
    if (fs.existsSync(outputPath)) {
      const outStat = fs.statSync(outputPath);
      if (outStat.size > 0 && outStat.mtimeMs >= sourceStat.mtimeMs) return outputPath;
    }

    const cacheKey = `${sourcePath}=>${outputPath}`;
    const existing = transcodeCache.get(cacheKey);
    if (existing) return existing;

    const task = (async () => {
      const commonOut = ['-c:v', 'libx264', '-preset', 'veryfast', '-pix_fmt', 'yuv420p', '-movflags', '+faststart', outputPath];
      const profiles: string[][] = [
        ['-hide_banner', '-loglevel', 'error', '-y', '-fflags', '+genpts', '-i', sourcePath, ...commonOut],
        ['-hide_banner', '-loglevel', 'error', '-y', '-r', '25', '-fflags', '+genpts', '-f', 'h264', '-i', sourcePath, ...commonOut],
        ['-hide_banner', '-loglevel', 'error', '-y', '-r', '20', '-f', 'h264', '-i', sourcePath, ...commonOut]
      ];
      if (safeInputFps && !/\.mp4$/i.test(sourcePath)) {
        profiles.unshift([
          '-hide_banner',
          '-loglevel',
          'error',
          '-y',
          '-fflags',
          '+genpts',
          '-framerate',
          String(safeInputFps),
          '-f',
          'h264',
          '-i',
          sourcePath,
          ...commonOut
        ]);
      }
      await runFfmpegProfiles(profiles, outputPath);
      return outputPath;
    })().finally(() => {
      transcodeCache.delete(cacheKey);
    });

    transcodeCache.set(cacheKey, task);
    return task;
  };
  const toPlayableMp4FromHttp = async (sourceUrl: string, cacheId: string) => {
    if (!sourceUrl) throw new Error('Missing source URL');
    if (/\.mp4(?:$|\?)/i.test(sourceUrl)) return sourceUrl;

    const outputDir = path.join(process.cwd(), 'recordings', 'transcoded', 'remote');
    try { fs.mkdirSync(outputDir, { recursive: true }); } catch {}
    const hash = crypto.createHash('sha1').update(`${cacheId}:${sourceUrl}`).digest('hex').slice(0, 16);
    const outputPath = path.join(outputDir, `${hash}.playable.mp4`);

    if (fs.existsSync(outputPath) && fs.statSync(outputPath).size > 0) {
      return outputPath;
    }

    const cacheKey = `http:${sourceUrl}=>${outputPath}`;
    const existing = transcodeCache.get(cacheKey);
    if (existing) return existing;

    const task = (async () => {
      const commonOut = ['-c:v', 'libx264', '-preset', 'veryfast', '-pix_fmt', 'yuv420p', '-movflags', '+faststart', outputPath];
      const profiles: string[][] = [
        ['-hide_banner', '-loglevel', 'error', '-y', '-fflags', '+genpts', '-i', sourceUrl, ...commonOut],
        ['-hide_banner', '-loglevel', 'error', '-y', '-reconnect', '1', '-reconnect_streamed', '1', '-reconnect_delay_max', '2', '-i', sourceUrl, ...commonOut]
      ];
      await runFfmpegProfiles(profiles, outputPath);
      return outputPath;
    })().finally(() => {
      transcodeCache.delete(cacheKey);
    });

    transcodeCache.set(cacheKey, task);
    return task;
  };
  const resolveAlertClipSource = (videoClips: any, type: 'pre' | 'post' | 'camera') => {
    if (type === 'pre') {
      // Prefer local raw clip path so we can transcode to browser-playable MP4.
      return String(videoClips?.pre || videoClips?.preStorageUrl || '').trim();
    }
    if (type === 'post') {
      // Prefer local raw clip path so we can transcode to browser-playable MP4.
      return String(videoClips?.post || videoClips?.postStorageUrl || '').trim();
    }
    return String(
      videoClips?.cameraVideoLocalPath ||
      videoClips?.cameraVideo ||
      ''
    ).trim();
  };
  const getAlertClipFpsHint = (videoClips: any, type: 'pre' | 'post' | 'camera') => {
    if (type === 'camera') return undefined;
    const duration = Number(type === 'pre' ? videoClips?.preDuration : videoClips?.postDuration);
    const frames = Number(type === 'pre' ? videoClips?.preFrameCount : videoClips?.postFrameCount);
    if (!Number.isFinite(duration) || !Number.isFinite(frames) || duration <= 0 || frames <= 0) {
      return undefined;
    }
    const fps = frames / duration;
    if (!Number.isFinite(fps) || fps <= 0) return undefined;
    return Math.max(0.2, Math.min(30, fps));
  };
  const buildManualVideoJob = (
    vehicleId: string,
    channel: number,
    start: Date,
    end: Date,
    options?: {
      alertId?: string;
      windowType?: 'pre' | 'post';
    }
  ) => {
    const id = `JOB-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
    const now = new Date().toISOString();
    const durationSec = Math.max(1, Math.min(300, Math.ceil((end.getTime() - start.getTime()) / 1000)));
    const outputDir = path.join(process.cwd(), 'recordings', vehicleId, 'manual');
    const outputName = `${id}_ch${channel}.mp4`;
    const outputPath = path.join(outputDir, outputName);
    const outputUrl = `/api/videos/jobs/${encodeURIComponent(id)}/file`;
    const job = {
      id,
      vehicleId,
      channel,
      startTime: start.toISOString(),
      endTime: end.toISOString(),
      alertId: options?.alertId,
      windowType: options?.windowType,
      status: 'queued' as const,
      createdAt: now,
      updatedAt: now,
      outputPath,
      outputUrl
    };
    manualVideoJobs.set(id, job);

    const playlistPath = path.join(process.cwd(), 'hls', vehicleId, `channel_${channel}`, 'playlist.m3u8');
    setTimeout(() => {
      const current = manualVideoJobs.get(id);
      if (!current) return;
      current.status = 'running';
      current.updatedAt = new Date().toISOString();
      manualVideoJobs.set(id, current);

      try {
        fs.mkdirSync(outputDir, { recursive: true });
      } catch {}

      const ffmpeg = spawn('ffmpeg', [
        '-hide_banner',
        '-loglevel', 'error',
        '-y',
        '-i', playlistPath,
        '-t', String(durationSec),
        '-c', 'copy',
        '-movflags', '+faststart',
        outputPath
      ], { stdio: ['ignore', 'ignore', 'pipe'] });

      let stderr = '';
      ffmpeg.stderr.on('data', (d) => { stderr += String(d || ''); });
      ffmpeg.on('error', (err) => {
        const failed = manualVideoJobs.get(id);
        if (!failed) return;
        failed.status = 'failed';
        failed.error = err?.message || 'ffmpeg spawn failed';
        failed.updatedAt = new Date().toISOString();
        manualVideoJobs.set(id, failed);
      });
      ffmpeg.on('close', (code) => {
        const finalJob = manualVideoJobs.get(id);
        if (!finalJob) return;
        const ok = code === 0 && fs.existsSync(outputPath);
        if (ok) {
          finalJob.status = 'completed';
          void persistManualJobVideo(finalJob).catch((err: any) => {
            const latest = manualVideoJobs.get(id);
            if (!latest) return;
            latest.error = `Persist failed: ${err?.message || 'unknown error'}`;
            latest.updatedAt = new Date().toISOString();
            manualVideoJobs.set(id, latest);
          });
        } else {
          finalJob.status = 'failed';
          finalJob.error = stderr?.slice(0, 500) || `ffmpeg exited with code ${code}`;
        }
        finalJob.updatedAt = new Date().toISOString();
        manualVideoJobs.set(id, finalJob);
      });
    }, 1200);

    return { id, outputUrl };
  };
  const toNumericLimit = (value: unknown, fallback: number, min = 1, max = 500) => {
    const n = Number(value);
    if (!Number.isFinite(n)) return fallback;
    return Math.max(min, Math.min(max, Math.floor(n)));
  };
  const toNumericMinutes = (value: unknown, fallback: number, min = 1, max = 7 * 24 * 60) => {
    const n = Number(value);
    if (!Number.isFinite(n)) return fallback;
    return Math.max(min, Math.min(max, Math.floor(n)));
  };
  const normalizeAlertRecord = (alert: any) => {
    const metadata = typeof alert?.metadata === 'string'
      ? (() => { try { return JSON.parse(alert.metadata || '{}'); } catch { return {}; } })()
      : (alert?.metadata || {});
    return {
      ...alert,
      metadata,
      vehicleId: alert?.vehicleId || alert?.device_id || alert?.deviceId,
      type: alert?.type || alert?.alert_type,
      priority: alert?.priority || 'high',
      status: alert?.status || (alert?.resolved ? 'resolved' : 'new'),
      timestamp: alert?.timestamp
    };
  };
  const mergeRecentAlerts = (lists: any[][], limit: number) => {
    const seen = new Set<string>();
    const merged: any[] = [];
    lists.flat().forEach((a: any) => {
      const id = String(a?.id || '').trim();
      if (!id || seen.has(id)) return;
      seen.add(id);
      merged.push(a);
    });
    merged.sort((a: any, b: any) => new Date(b?.timestamp || 0).getTime() - new Date(a?.timestamp || 0).getTime());
    return merged.slice(0, limit);
  };

  const persistManualJobVideo = async (job: {
    id: string;
    vehicleId: string;
    channel: number;
    startTime: string;
    endTime: string;
    alertId?: string;
    windowType?: 'pre' | 'post';
    outputPath?: string;
  }) => {
    if (!job.outputPath || !fs.existsSync(job.outputPath)) return;

    const stats = fs.statSync(job.outputPath);
    const start = new Date(job.startTime);
    const end = new Date(job.endTime);
    const duration = Math.max(1, Math.round((end.getTime() - start.getTime()) / 1000));
    const videoType = job.alertId ? 'camera_sd' : 'manual';

    const videoId = await videoStorage.saveVideo(
      job.vehicleId,
      job.channel,
      job.outputPath,
      start,
      videoType,
      job.alertId
    );
    await videoStorage.updateVideoEnd(videoId, end, stats.size, duration);

    let persistedUrl = `/api/videos/jobs/${encodeURIComponent(job.id)}/file`;
    if (process.env.SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY) {
      const uploaded = await videoStorage.uploadVideoToSupabase(
        videoId,
        job.outputPath,
        job.vehicleId,
        job.channel
      );
      if (uploaded) persistedUrl = normalizePublicVideoUrl(uploaded, persistedUrl);
    }

    const current = manualVideoJobs.get(job.id);
    if (current) {
      current.persistedVideoId = String(videoId);
      current.persistedVideoUrl = persistedUrl;
      current.updatedAt = new Date().toISOString();
      manualVideoJobs.set(job.id, current);
    }

    if (job.alertId) {
      const alertResult = await dbQuery(
        'SELECT metadata FROM alerts WHERE id = $1',
        [job.alertId]
      );
      if (alertResult.rows.length > 0) {
        const rawMeta = alertResult.rows[0].metadata;
        const metadata = typeof rawMeta === 'string' ? JSON.parse(rawMeta || '{}') : (rawMeta || {});
        metadata.videoClips = metadata.videoClips || {};
        const normalized = normalizePublicVideoUrl(
          persistedUrl,
          `/api/videos/jobs/${encodeURIComponent(job.id)}/file`
        );
        if (job.windowType === 'pre') {
          metadata.videoClips.cameraPreVideo = normalized;
          metadata.videoClips.cameraPreVideoLocalPath = job.outputPath;
          metadata.videoClips.cameraPreVideoJobId = job.id;
          metadata.videoClips.cameraPreVideoVideoId = String(videoId);
          // Preserve legacy fields for existing clients.
          metadata.videoClips.cameraVideo = normalized;
          metadata.videoClips.cameraVideoLocalPath = job.outputPath;
          metadata.videoClips.cameraVideoJobId = job.id;
          metadata.videoClips.cameraVideoVideoId = String(videoId);
        } else if (job.windowType === 'post') {
          metadata.videoClips.cameraPostVideo = normalized;
          metadata.videoClips.cameraPostVideoLocalPath = job.outputPath;
          metadata.videoClips.cameraPostVideoJobId = job.id;
          metadata.videoClips.cameraPostVideoVideoId = String(videoId);
        } else {
          metadata.videoClips.cameraVideo = normalized;
          metadata.videoClips.cameraVideoLocalPath = job.outputPath;
          metadata.videoClips.cameraVideoJobId = job.id;
          metadata.videoClips.cameraVideoVideoId = String(videoId);
        }
        await dbQuery(
          'UPDATE alerts SET metadata = $1 WHERE id = $2',
          [JSON.stringify(metadata), job.alertId]
        );
      }
    }
  };

  // Auto-capture and persist an alert-linked playback file whenever alert workflow
  // requests camera video. This ensures alert APIs return a video URL once ready.
  const alertManager = tcpServer.getAlertManager();
  alertManager.on('request-camera-video', ({ vehicleId, channel, startTime, endTime, alertId, windowType }) => {
    if (!alertId || !vehicleId) return;
    const dedupeKey = `${String(alertId)}:${String(windowType || 'generic')}`;
    if (queuedAlertWindows.has(dedupeKey)) return;
    queuedAlertWindows.add(dedupeKey);
    buildManualVideoJob(
      String(vehicleId),
      Number(channel || 1),
      new Date(startTime),
      new Date(endTime),
      { alertId: String(alertId), windowType: windowType === 'post' ? 'post' : 'pre' }
    );
  });

  // Get all connected vehicles with their channels
  router.get('/vehicles', (req, res) => {
    const vehicles = tcpServer.getVehicles();
    res.json({
      success: true,
      data: vehicles.map(v => ({
        id: v.id,
        phone: v.phone,
        connected: v.connected,
        lastHeartbeat: v.lastHeartbeat,
        activeStreams: Array.from(v.activeStreams),
        channels: v.channels || []
      }))
    });
  });

  // Start all video channels for a vehicle
  router.post('/vehicles/:id/start-all-streams', (req, res) => {
    const { id } = req.params;
    const vehicle = tcpServer.getVehicle(id);

    if (!vehicle || !vehicle.connected) {
      return res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found or not connected`
      });
    }

    const videoChannels = vehicle.channels?.filter(ch => ch.type === 'video' || ch.type === 'audio_video') || [];
    const results = [];

    for (const channel of videoChannels) {
      const success = tcpServer.startVideo(id, channel.logicalChannel);
      results.push({
        channel: channel.logicalChannel,
        type: channel.type,
        success
      });
    }

    res.json({
      success: true,
      message: `Started ${results.filter(r => r.success).length}/${results.length} video streams`,
      data: results
    });
  });

  // Stop all video channels for a vehicle
  router.post('/vehicles/:id/stop-all-streams', (req, res) => {
    const { id } = req.params;
    const vehicle = tcpServer.getVehicle(id);

    if (!vehicle) {
      return res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found`
      });
    }

    const activeChannels = Array.from(vehicle.activeStreams);
    const results = [];

    for (const channel of activeChannels) {
      const success = tcpServer.stopVideo(id, channel);
      udpServer.stopStream(id, channel);
      results.push({ channel, success });
    }

    res.json({
      success: true,
      message: `Stopped ${results.length} video streams`,
      data: results
    });
  });

  // Start live video for a vehicle
  router.post('/vehicles/:id/start-live', (req, res) => {
    const { id } = req.params;
    const { channel = 1 } = req.body;

    console.log(`ðŸ“¡ API: start-live called for vehicle ${id}, channel ${channel}`);

    const success = tcpServer.startVideo(id, channel);
    if (success) {
      udpServer.startHLSStream(id, channel);
      res.json({
        success: true,
        message: `Video stream started for vehicle ${id}, channel ${channel}`
      });
    } else {
      res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found or not connected`
      });
    }
  });

  // Optimize camera video parameters
  router.post('/vehicles/:id/optimize-video', (req, res) => {
    const { id } = req.params;
    const { channel = 1 } = req.body;

    const success = tcpServer.optimizeVideoParameters(id, channel);

    if (success) {
      res.json({
        success: true,
        message: `Camera optimized for ${id} channel ${channel}`,
        settings: {
          resolution: 'CIF (352x288)',
          frameRate: '15 fps',
          bitrate: '512 kbps',
          speedup: '3-5x faster'
        }
      });
    } else {
      res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found`
      });
    }
  });

  // Configure video alarm mask (0x007A). maskWord=0 un-masks all video alarms.
  router.post('/vehicles/:id/config/video-alarm-mask', (req, res) => {
    const { id } = req.params;
    const maskWord = Number(req.body?.maskWord ?? 0) >>> 0;
    const success = tcpServer.setVideoAlarmMask(id, maskWord);

    if (success) {
      return res.json({
        success: true,
        message: `Video alarm mask set for ${id}`,
        data: {
          vehicleId: id,
          maskWord,
          maskHex: `0x${maskWord.toString(16).padStart(8, '0')}`
        }
      });
    }

    return res.status(404).json({
      success: false,
      message: `Vehicle ${id} not found or not connected`
    });
  });

  // Switch stream quality
  router.post('/vehicles/:id/switch-stream', (req, res) => {
    const { id } = req.params;
    const { channel = 1, streamType = 1 } = req.body; // 0=main, 1=sub

    const success = tcpServer.switchStream(id, channel, streamType);

    if (success) {
      res.json({
        success: true,
        message: `Switched to ${streamType === 0 ? 'main' : 'sub'} stream for vehicle ${id}, channel ${channel}`
      });
    } else {
      res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found or not connected`
      });
    }
  });

  // Stop live video for a vehicle
  router.post('/vehicles/:id/stop-live', (req, res) => {
    const { id } = req.params;
    const { channel = 1 } = req.body;

    const success = tcpServer.stopVideo(id, channel);
    udpServer.stopStream(id, channel);

    // Also stop TCP RTP handler stream
    const tcpRTPHandler = (tcpServer as any).rtpHandler;
    if (tcpRTPHandler?.stopStream) {
      tcpRTPHandler.stopStream(id, channel);
    }

    if (success) {
      res.json({
        success: true,
        message: `Video stream stopped for vehicle ${id}, channel ${channel}`
      });
    } else {
      res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found`
      });
    }
  });

  // Request screenshot from vehicle
  router.post('/vehicles/:id/screenshot', async (req, res) => {
    const { id } = req.params;
    const { channel = 1, fallback = true, fallbackDelayMs = 600 } = req.body;
    const result = await tcpServer.requestScreenshotWithFallback(id, Number(channel), {
      fallback: !!fallback,
      fallbackDelayMs: Number(fallbackDelayMs)
    });

    if (!result.success) {
      res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found or not connected`
      });
      return;
    }

    res.json({
      success: true,
      message: `Screenshot requested for vehicle ${id}, channel ${channel}`,
      fallback: result.fallback || { ok: false, reason: 'disabled' }
    });
  });

  // Alias route used by external frontend proxy path
  router.post('/video-server/vehicles/:id/screenshot', async (req, res) => {
    const { id } = req.params;
    const { channel = 1, fallback = true, fallbackDelayMs = 600 } = req.body;
    const result = await tcpServer.requestScreenshotWithFallback(id, Number(channel), {
      fallback: !!fallback,
      fallbackDelayMs: Number(fallbackDelayMs)
    });

    if (!result.success) {
      return res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found or not connected`
      });
    }

    res.json({
      success: true,
      message: `Screenshot requested for vehicle ${id}, channel ${channel}`,
      fallback: result.fallback || { ok: false, reason: 'disabled' }
    });
  });

  // Get stream info for a vehicle
  router.get('/vehicles/:id/stream-info', (req, res) => {
    const { id } = req.params;
    const { channel = 1 } = req.query;

    const vehicle = tcpServer.getVehicle(id);
    const streamInfo = udpServer.getStreamInfo(id, Number(channel));

    if (!vehicle) {
      return res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found`
      });
    }

    res.json({
      success: true,
      data: {
        vehicle: {
          id: vehicle.id,
          connected: vehicle.connected,
          lastHeartbeat: vehicle.lastHeartbeat
        },
        stream: streamInfo || {
          vehicleId: id,
          channel: Number(channel),
          active: false,
          frameCount: 0,
          lastFrame: null
        }
      }
    });
  });

  // Get all active streams for a vehicle
  router.get('/vehicles/:id/streams', (req, res) => {
    const { id } = req.params;
    const vehicle = tcpServer.getVehicle(id);

    if (!vehicle) {
      return res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found`
      });
    }

    const streams = [];
    for (const channel of vehicle.activeStreams) {
      const streamInfo = udpServer.getStreamInfo(id, channel);
      const channelInfo = vehicle.channels?.find(ch => ch.logicalChannel === channel);

      streams.push({
        channel,
        type: channelInfo?.type || 'unknown',
        hasGimbal: channelInfo?.hasGimbal || false,
        streamInfo: streamInfo || {
          vehicleId: id,
          channel,
          active: false,
          frameCount: 0,
          lastFrame: null
        },
        playlistUrl: `/api/stream/${id}/${channel}/playlist.m3u8`
      });
    }

    res.json({
      success: true,
      data: {
        vehicleId: id,
        totalChannels: vehicle.channels?.length || 0,
        activeStreams: streams.length,
        streams
      }
    });
  });

  // Query camera capabilities
  router.post('/vehicles/:id/query-capabilities', (req, res) => {
    const { id } = req.params;

    const success = tcpServer.queryCapabilities(id);

    if (success) {
      res.json({
        success: true,
        message: `Querying capabilities for vehicle ${id}, check logs for response`
      });
    } else {
      res.status(404).json({
        success: false,
        message: `Vehicle ${id} not found or not connected`
      });
    }
  });

  // Get server statistics
  router.get('/stats', (req, res) => {
    const vehicles = tcpServer.getVehicles();
    const udpStats = udpServer.getStats();

    res.json({
      success: true,
      data: {
        connectedVehicles: vehicles.filter(v => v.connected).length,
        totalVehicles: vehicles.length,
        activeStreams: udpStats.activeStreams,
        totalStreams: udpStats.totalStreams,
        frameAssembler: udpStats.frameAssemblerStats
      }
    });
  });

  // Serve HLS playlist
  router.get('/stream/:vehicleId/:channel/playlist.m3u8', (req, res) => {
    const { vehicleId, channel } = req.params;
    const playlistPath = path.join(process.cwd(), 'hls', vehicleId, `channel_${channel}`, 'playlist.m3u8');
    res.sendFile(playlistPath);
  });

  // Serve HLS segments
  router.get('/stream/:vehicleId/:channel/:segment', (req, res) => {
    const { vehicleId, channel, segment } = req.params;
    const segmentPath = path.join(process.cwd(), 'hls', vehicleId, `channel_${channel}`, segment);
    res.sendFile(segmentPath);
  });

  // Get alerts
  router.get('/alerts', async (req, res) => {
    try {
      const alertManager = tcpServer.getAlertManager();
      const status = String(req.query.status || '').trim();
      const priority = String(req.query.priority || '').trim();
      const limit = toNumericLimit(req.query.limit, 10);
      const hasMinutesFilter = req.query.minutes !== undefined && req.query.minutes !== null && String(req.query.minutes).trim() !== '';
      const minutes = hasMinutesFilter ? toNumericMinutes(req.query.minutes, 180) : null;

      const memAlertsRaw = alertManager.getActiveAlerts();
      let memAlerts = memAlertsRaw.map((a: any) => normalizeAlertRecord(a));
      if (status) memAlerts = memAlerts.filter((a: any) => String(a?.status || '').toLowerCase() === status.toLowerCase());
      if (priority) memAlerts = memAlerts.filter((a: any) => String(a?.priority || '').toLowerCase() === priority.toLowerCase());

      const where: string[] = [];
      const params: any[] = [];
      let p = 1;
      if (minutes !== null) {
        where.push(`timestamp >= NOW() - ($${p++}::int * INTERVAL '1 minute')`);
        params.push(minutes);
      }
      if (status) {
        where.push(`LOWER(COALESCE(status, '')) = LOWER($${p++})`);
        params.push(status);
      }
      if (priority) {
        where.push(`LOWER(COALESCE(priority, '')) = LOWER($${p++})`);
        params.push(priority);
      }
      params.push(Math.max(limit * 5, 50));
      const dbResult = await require('../storage/database').query(
        `SELECT id, device_id, channel, alert_type, priority, status, timestamp, metadata
         FROM alerts
         ${where.length ? `WHERE ${where.join(' AND ')}` : ''}
         ORDER BY timestamp DESC
         LIMIT $${p}`,
        params
      );
      const dbAlerts = dbResult.rows.map((r: any) => normalizeAlertRecord(r));

      const alerts = mergeRecentAlerts([memAlerts, dbAlerts], limit).map(withAlertMediaLinks);
      res.json({
        success: true,
        alerts,
        count: alerts.length,
        source: 'merged',
        window_minutes: minutes
      });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Failed to fetch alerts' });
    }
  });

  // Get vehicle images
  router.get('/vehicles/:id/images', async (req, res) => {
    const { id } = req.params;
    const limit = parseInt(req.query.limit as string) || 50;

    try {
      const result = await require('../storage/database').query(
        `SELECT id, device_id, channel, storage_url, file_size, timestamp 
         FROM images 
         WHERE device_id = $1 
         ORDER BY timestamp DESC 
         LIMIT $2`,
        [id, limit]
      );

      res.json({
        success: true,
        data: result.rows.map((img: any) => ({
          id: img.id,
          deviceId: img.device_id,
          channel: img.channel,
          url: img.storage_url,
          fileSize: img.file_size,
          timestamp: img.timestamp
        }))
      });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Failed to fetch images' });
    }
  });

  // Serve media files
  router.get('/media/:vehicleId/:filename', (req, res) => {
    const { vehicleId, filename } = req.params;
    const { download } = req.query;
    const filePath = path.join(process.cwd(), 'media', vehicleId, filename);

    if (require('fs').existsSync(filePath)) {
      // Set proper content type for images
      if (filename.match(/\.(jpg|jpeg)$/i)) {
        res.setHeader('Content-Type', 'image/jpeg');
      } else if (filename.match(/\.png$/i)) {
        res.setHeader('Content-Type', 'image/png');
      } else if (filename.match(/\.mp4$/i)) {
        res.setHeader('Content-Type', 'video/mp4');
      }

      if (download === 'true') {
        res.download(filePath, filename);
      } else {
        res.sendFile(path.resolve(filePath));
      }
    } else {
      res.status(404).json({ success: false, message: 'File not found' });
    }
  });

  // Get all images from all vehicles
  router.get('/images', async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 100;
      const result = await require('../storage/database').query(
        `SELECT id, device_id, channel, storage_url, file_size, timestamp 
         FROM images 
         ORDER BY timestamp DESC 
         LIMIT $1`,
        [limit]
      );

      res.json({
        success: true,
        total: result.rows.length,
        data: result.rows.map((img: any) => ({
          id: img.id,
          deviceId: img.device_id,
          channel: img.channel,
          url: img.storage_url,
          fileSize: img.file_size,
          timestamp: img.timestamp
        }))
      });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Failed to fetch images' });
    }
  });

  // Get all devices
  router.get('/devices', async (req, res) => {
    const devices = await tcpServer.getDevices();
    res.json({
      success: true,
      total: devices.length,
      data: devices
    });
  });

  // === ALERT MANAGEMENT ENDPOINTS ===
  // IMPORTANT: Specific routes MUST come BEFORE parameterized routes (/alerts/:id)

  // Get active alerts
  router.get('/alerts/active', async (req, res) => {
    try {
      const alertManager = tcpServer.getAlertManager();
      const limit = toNumericLimit(req.query.limit, 50);
      const hasMinutesFilter = req.query.minutes !== undefined && req.query.minutes !== null && String(req.query.minutes).trim() !== '';
      const minutes = hasMinutesFilter ? toNumericMinutes(req.query.minutes, 180) : null;

      const memAlerts = alertManager
        .getActiveAlerts()
        .map((a: any) => normalizeAlertRecord(a))
        .filter((a: any) => ['new', 'acknowledged', 'escalated'].includes(String(a?.status || '').toLowerCase()));

      let dbAlerts: any[] = [];
      try {
        const dbWhere: string[] = [
          `(resolved IS DISTINCT FROM TRUE)`,
          `(status IS NULL OR LOWER(status) NOT IN ('resolved', 'closed'))`
        ];
        const dbParams: any[] = [];
        let px = 1;
        if (minutes !== null) {
          dbWhere.push(`timestamp >= NOW() - ($${px++}::int * INTERVAL '1 minute')`);
          dbParams.push(minutes);
        }
        dbParams.push(Math.max(limit * 5, 50));
        const dbResult = await require('../storage/database').query(
          `SELECT id, device_id, channel, alert_type, priority, status, timestamp, metadata
           FROM alerts
           WHERE ${dbWhere.join(' AND ')}
           ORDER BY timestamp DESC
           LIMIT $${px}`,
          dbParams
        );
        dbAlerts = dbResult.rows.map((r: any) => normalizeAlertRecord(r));
      } catch (dbErr: any) {
        console.error('alerts/active DB query failed:', dbErr?.message || dbErr);
      }
      const alerts = mergeRecentAlerts([memAlerts, dbAlerts], limit).map(withAlertMediaLinks);

      res.json({
        success: true,
        alerts,
        count: alerts.length,
        source: 'merged',
        window_minutes: minutes
      });
    } catch (error: any) {
      console.error('alerts/active failed:', error?.message || error);
      // Final fallback: in-memory only
      try {
        const fallbackLimit = toNumericLimit(req.query.limit, 10);
        const memOnly = tcpServer.getAlertManager()
          .getActiveAlerts()
          .map((a: any) => normalizeAlertRecord(a))
          .slice(0, fallbackLimit)
          .map(withAlertMediaLinks);
        return res.json({
          success: true,
          alerts: memOnly,
          count: memOnly.length,
          source: 'memory-fallback',
          window_minutes: toNumericMinutes(req.query.minutes, 180)
        });
      } catch {
        return res.status(500).json({ success: false, message: 'Failed to fetch active alerts' });
      }
    }
  });

  // Get alert statistics (moved before :id)
  router.get('/alerts/stats', (req, res) => {
    const alertManager = tcpServer.getAlertManager();
    const stats = alertManager.getAlertStats();
    res.json({
      success: true,
      stats: {
        total: stats.total,
        byStatus: {
          new: stats.new,
          acknowledged: stats.acknowledged,
          escalated: stats.escalated,
          resolved: stats.resolved
        },
        byPriority: stats.byPriority
      }
    });
  });

  // Get unresolved alerts
  router.get('/alerts/unresolved', async (req, res) => {
    try {
      const result = await require('../storage/database').query(
        `SELECT a.*, 
                EXTRACT(EPOCH FROM (NOW() - a.timestamp))/60 as minutes_open
         FROM alerts a
         WHERE status IN ('new', 'acknowledged', 'escalated')
         ORDER BY timestamp DESC`
      );
      res.json({ success: true, total: result.rows.length, data: result.rows });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Failed to fetch unresolved alerts' });
    }
  });

  // Get driver behavior alerts
  router.get('/alerts/driver-behavior', async (req, res) => {
    try {
      const result = await require('../storage/database').query(
        `SELECT * FROM alerts 
         WHERE alert_type IN ('Driver Fatigue', 'Phone Call While Driving', 'Smoking While Driving')
         ORDER BY timestamp DESC LIMIT 100`
      );
      res.json({ success: true, total: result.rows.length, data: result.rows });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Failed to fetch driver behavior alerts' });
    }
  });

  // Get alerts by device
  router.get('/alerts/by-device', async (req, res) => {
    try {
      const result = await require('../storage/database').query(
        `SELECT device_id, COUNT(*) as total_alerts,
                COUNT(*) FILTER (WHERE status = 'new') as new_alerts,
                COUNT(*) FILTER (WHERE priority = 'critical') as critical_alerts,
                MAX(timestamp) as last_alert_time
         FROM alerts
         GROUP BY device_id
         ORDER BY MAX(timestamp) DESC`
      );
      res.json({ success: true, total: result.rows.length, data: result.rows });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Failed to fetch alerts by device' });
    }
  });

  // Get alert history
  router.get('/alerts/history', async (req, res) => {
    try {
      const { device_id, days = 7 } = req.query;
      const limit = toNumericLimit(req.query.limit, 100, 1, 1000);
      let query = `SELECT * FROM alerts WHERE timestamp > NOW() - INTERVAL '${days} days'`;
      const params: any[] = [];
      if (device_id) {
        query += ' AND device_id = $1';
        params.push(device_id);
      }
      query += ' ORDER BY timestamp DESC LIMIT $' + (params.length + 1);
      params.push(limit);
      const result = await require('../storage/database').query(query, params);
      res.json({ success: true, total: result.rows.length, data: result.rows });
    } catch (error) {
      res.status(500).json({ success: false, message: 'Failed to fetch alert history' });
    }
  });

  // Get alerts grouped by priority (moved before :id)
  router.get('/alerts/by-priority', (req, res) => {
    const alertManager = tcpServer.getAlertManager();
    const alerts = alertManager.getActiveAlerts();

    const grouped = {
      critical: alerts.filter(a => a.priority === 'critical'),
      high: alerts.filter(a => a.priority === 'high'),
      medium: alerts.filter(a => a.priority === 'medium'),
      low: alerts.filter(a => a.priority === 'low')
    };

    res.json({
      success: true,
      alertsByPriority: grouped,
      counts: {
        critical: grouped.critical.length,
        high: grouped.high.length,
        medium: grouped.medium.length,
        low: grouped.low.length,
        total: alerts.length
      }
    });
  });

  // Get unattended alerts (moved before :id)
  router.get('/alerts/unattended', async (req, res) => {
    const minutesThreshold = parseInt(req.query.minutes as string) || 30;

    try {
      const alertStorage = require('../storage/alertStorageDB');
      const alerts = await new alertStorage.AlertStorageDB().getUnattendedAlerts(minutesThreshold);

      res.json({
        success: true,
        unattendedAlerts: alerts,
        count: alerts.length,
        threshold_minutes: minutesThreshold
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Failed to fetch unattended alerts'
      });
    }
  });

  // Get buffer statistics (moved before :id)
  router.get('/alerts/buffers/stats', (req, res) => {
    const alertManager = tcpServer.getAlertManager();
    const stats = alertManager.getBufferStats();
    res.json({
      success: true,
      data: stats
    });
  });

  // Get normalized alert signals for one alert
  router.get('/alerts/:id/signals', async (req, res) => {
    const { id } = req.params;

    try {
      const result = await require('../storage/database').query(
        `SELECT id, alert_type, priority, timestamp, metadata
         FROM alerts
         WHERE id = $1`,
        [id]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: `Alert ${id} not found`
        });
      }

      const row = result.rows[0];
      const metadata = typeof row.metadata === 'string' ? JSON.parse(row.metadata) : (row.metadata || {});

      res.json({
        success: true,
        data: {
          id: row.id,
          timestamp: row.timestamp,
          priority: row.priority,
          primaryAlertType: metadata.primaryAlertType || row.alert_type,
          alertSignals: metadata.alertSignals || [],
          alertSignalDetails: metadata.alertSignalDetails || [],
          alarmFlags: metadata.alarmFlags || {},
          alarmFlagSetBits: metadata.alarmFlagSetBits || [],
          videoAlarms: metadata.videoAlarms || {},
          drivingBehavior: metadata.drivingBehavior || {},
          rawAlarmFlag: metadata.rawAlarmFlag,
          rawStatusFlag: metadata.rawStatusFlag
        }
      });
    } catch (error: any) {
      res.status(500).json({
        success: false,
        message: 'Failed to fetch alert signals',
        error: error?.message
      });
    }
  });

  // Get alert by ID
  router.get('/alerts/:id', async (req, res) => {
    const { id } = req.params;
    const alertManager = tcpServer.getAlertManager();
    let alert: any = alertManager.getAlertById(id);

    if (!alert) {
      try {
        const dbAlert = await dbQuery(
          `SELECT id, device_id, channel, alert_type, priority, status, timestamp, metadata
           FROM alerts
           WHERE id = $1`,
          [id]
        );
        if (dbAlert.rows.length > 0) {
          const row = dbAlert.rows[0];
          alert = {
            id: row.id,
            vehicleId: row.device_id,
            channel: row.channel,
            type: row.alert_type,
            priority: row.priority,
            status: row.status,
            timestamp: row.timestamp,
            metadata: typeof row.metadata === 'string' ? JSON.parse(row.metadata || '{}') : (row.metadata || {})
          };
        }
      } catch {}
    }

    if (!alert) {
      return res.status(404).json({
        success: false,
        message: `Alert ${id} not found`
      });
    }

    // Get associated screenshots
    try {
      const screenshots = await require('../storage/database').query(
        `SELECT id, storage_url, timestamp 
         FROM images 
         WHERE alert_id = $1 
         ORDER BY timestamp ASC`,
        [id]
      );

      res.json({
        success: true,
        alert: {
          ...withAlertMediaLinks(alert),
          videoUrl: normalizePublicVideoUrl(
            `/api/alerts/${encodeURIComponent(id)}/video/pre`,
            `/api/alerts/${encodeURIComponent(id)}/video/pre`
          ),
          preIncidentVideoUrl: `/api/alerts/${encodeURIComponent(id)}/video/pre`,
          postIncidentVideoUrl: `/api/alerts/${encodeURIComponent(id)}/video/post`,
          cameraVideoUrl: `/api/alerts/${encodeURIComponent(id)}/video/camera`,
          preIncidentRawUrl: normalizePublicVideoUrl(
            alert?.metadata?.videoClips?.preStorageUrl || alert?.metadata?.videoClips?.pre,
            `/api/alerts/${encodeURIComponent(id)}/video/pre`
          ),
          postIncidentRawUrl: normalizePublicVideoUrl(
            alert?.metadata?.videoClips?.postStorageUrl || alert?.metadata?.videoClips?.post,
            `/api/alerts/${encodeURIComponent(id)}/video/post`
          ),
	          preIncidentReady: !!(alert?.metadata?.videoClips?.pre || alert?.metadata?.videoClips?.preStorageUrl) &&
	            Number(alert?.metadata?.videoClips?.preDuration || 0) >= Math.max(3, Number(process.env.MIN_ALERT_CLIP_SECONDS || 20)),
	          postIncidentReady: !!(alert?.metadata?.videoClips?.post || alert?.metadata?.videoClips?.postStorageUrl) &&
	            Number(alert?.metadata?.videoClips?.postDuration || 0) >= Math.max(3, Number(process.env.MIN_ALERT_CLIP_SECONDS || 20)),
          screenshots: screenshots.rows
        }
      });
    } catch (error) {
      res.json({
        success: true,
        alert: {
          ...withAlertMediaLinks(alert),
          videoUrl: normalizePublicVideoUrl(
            `/api/alerts/${encodeURIComponent(id)}/video/pre`,
            `/api/alerts/${encodeURIComponent(id)}/video/pre`
          ),
          preIncidentVideoUrl: `/api/alerts/${encodeURIComponent(id)}/video/pre`,
          postIncidentVideoUrl: `/api/alerts/${encodeURIComponent(id)}/video/post`,
          cameraVideoUrl: `/api/alerts/${encodeURIComponent(id)}/video/camera`,
          preIncidentRawUrl: normalizePublicVideoUrl(
            alert?.metadata?.videoClips?.preStorageUrl || alert?.metadata?.videoClips?.pre,
            `/api/alerts/${encodeURIComponent(id)}/video/pre`
          ),
          postIncidentRawUrl: normalizePublicVideoUrl(
            alert?.metadata?.videoClips?.postStorageUrl || alert?.metadata?.videoClips?.post,
            `/api/alerts/${encodeURIComponent(id)}/video/post`
          ),
	          preIncidentReady: !!(alert?.metadata?.videoClips?.pre || alert?.metadata?.videoClips?.preStorageUrl) &&
	            Number(alert?.metadata?.videoClips?.preDuration || 0) >= Math.max(3, Number(process.env.MIN_ALERT_CLIP_SECONDS || 20)),
	          postIncidentReady: !!(alert?.metadata?.videoClips?.post || alert?.metadata?.videoClips?.postStorageUrl) &&
	            Number(alert?.metadata?.videoClips?.postDuration || 0) >= Math.max(3, Number(process.env.MIN_ALERT_CLIP_SECONDS || 20))
        }
      });
    }
  });

  // Acknowledge alert
  router.post('/alerts/:id/acknowledge', async (req, res) => {
    const { id } = req.params;
    const alertManager = tcpServer.getAlertManager();
    const success = await alertManager.acknowledgeAlert(id);

    if (success) {
      res.json({
        success: true,
        message: `Alert ${id} acknowledged`
      });
    } else {
      res.status(404).json({
        success: false,
        message: `Alert ${id} not found or already acknowledged`
      });
    }
  });

  // Resolve alert
  router.post('/alerts/:id/resolve', async (req, res) => {
    const { id } = req.params;
    const alertManager = tcpServer.getAlertManager();
    const success = await alertManager.resolveAlert(id);

    if (success) {
      res.json({
        success: true,
        message: `Alert ${id} resolved`
      });
    } else {
      res.status(404).json({
        success: false,
        message: `Alert ${id} not found`
      });
    }
  });

  // Manually escalate alert
  router.post('/alerts/:id/escalate', async (req, res) => {
    const { id } = req.params;
    const alertManager = tcpServer.getAlertManager();
    const success = await alertManager.escalateAlert(id);

    if (success) {
      res.json({
        success: true,
        message: `Alert ${id} escalated`
      });
    } else {
      res.status(404).json({
        success: false,
        message: `Alert ${id} not found`
      });
    }
  });

  // Get video clip for alert
  router.get('/alerts/:id/video', (req, res) => {
    const { id } = req.params;
    const alertManager = tcpServer.getAlertManager();
    const alert = alertManager.getAlertById(id);

    if (!alert || !alert.videoClipPath) {
      return res.status(404).json({
        success: false,
        message: 'Video clip not found'
      });
    }

    if (require('fs').existsSync(alert.videoClipPath)) {
      res.sendFile(path.resolve(alert.videoClipPath));
    } else {
      res.status(404).json({
        success: false,
        message: 'Video file not found on disk'
      });
    }
  });

  // Get playable video clip for alert by type (pre/post/camera)
  router.get('/alerts/:id/video/:type', async (req, res) => {
    const { id } = req.params;
    const rawType = String(req.params.type || '').toLowerCase();
    const type = rawType === 'pre' || rawType === 'post' || rawType === 'camera'
      ? (rawType as 'pre' | 'post' | 'camera')
      : null;

    if (!type) {
      return res.status(400).json({
        success: false,
        message: 'Invalid type. Use pre, post, or camera'
      });
    }

    try {
      const db = require('../storage/database');
      const result = await db.query(
        `SELECT id, metadata FROM alerts WHERE id = $1`,
        [id]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: `Alert ${id} not found`
        });
      }

      const rawMeta = result.rows[0].metadata;
      const metadata = typeof rawMeta === 'string' ? JSON.parse(rawMeta || '{}') : (rawMeta || {});
      const videoClips = metadata?.videoClips || {};
      const source = resolveAlertClipSource(videoClips, type);
      const fpsHint = getAlertClipFpsHint(videoClips, type);

      if (!source) {
        return res.status(404).json({
          success: false,
          message: `${type} clip not found`
        });
      }

      if (/^https?:\/\//i.test(source)) {
        let playablePath: string = source;
        let contentType = 'video/mp4';
        try {
          playablePath = await toPlayableMp4FromHttp(source, `${id}:${type}`);
        } catch (transcodeErr) {
          console.error(`HTTP transcode failed for alert ${id} ${type}:`, transcodeErr);
          playablePath = source;
          contentType = /\.mp4(?:$|\?)/i.test(source) ? 'video/mp4' : 'video/h264';
        }
        if (/^https?:\/\//i.test(playablePath)) {
          return res.redirect(playablePath);
        }
        res.setHeader('Content-Type', contentType);
        res.setHeader('Content-Disposition', `inline; filename="${id}_${type}${contentType === 'video/mp4' ? '.mp4' : '.h264'}"`);
        return res.sendFile(path.resolve(playablePath));
      }
      if (source.startsWith('/api/')) {
        return res.redirect(source);
      }

      const sourcePath = path.isAbsolute(source)
        ? source
        : path.join(process.cwd(), source);
      if (!fs.existsSync(sourcePath)) {
        return res.status(404).json({
          success: false,
          message: `Source clip missing: ${source}`
        });
      }

      let playablePath = sourcePath;
      let contentType = 'video/mp4';
      try {
        playablePath = await toPlayableMp4(sourcePath, fpsHint);
      } catch (transcodeErr) {
        console.error(`Transcode failed for alert ${id} ${type}:`, transcodeErr);
        playablePath = sourcePath;
        contentType = /\.mp4$/i.test(sourcePath) ? 'video/mp4' : 'video/h264';
      }

      res.setHeader('Content-Type', contentType);
      res.setHeader('Content-Disposition', `inline; filename="${id}_${type}${contentType === 'video/mp4' ? '.mp4' : '.h264'}"`);
      return res.sendFile(path.resolve(playablePath));
    } catch (error: any) {
      return res.status(500).json({
        success: false,
        message: 'Failed to fetch alert video',
        error: error?.message || String(error)
      });
    }
  });

  // Get alert history
  router.get('/alerts/:id/history', async (req, res) => {
    const { id } = req.params;
    try {
      const db = require('../storage/database');

      // Get alert and its history from database
      const [alertResult, historyResult] = await Promise.all([
        db.query('SELECT * FROM alerts WHERE id = $1', [id]),
        db.query(
          `SELECT action_type, action_by, action_at, notes 
           FROM alert_history 
           WHERE alert_id = $1 
           ORDER BY action_at DESC`,
          [id]
        ).catch(() => ({ rows: [] })) // Table may not exist
      ]);

      if (alertResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: `Alert ${id} not found`
        });
      }

      const alert = alertResult.rows[0];

      // Build history from alert data if history table is empty
      const history = historyResult.rows.length > 0 ? historyResult.rows : [
        { action_type: 'created', action_at: alert.timestamp, notes: null },
        ...(alert.acknowledged_at ? [{ action_type: 'acknowledged', action_at: alert.acknowledged_at, notes: null }] : []),
        ...(alert.escalated_at ? [{ action_type: 'escalated', action_at: alert.escalated_at, notes: null }] : []),
        ...(alert.resolved_at ? [{ action_type: 'resolved', action_at: alert.resolved_at, notes: alert.resolution_notes }] : [])
      ];

      res.json({
        success: true,
        data: {
          alert_id: id,
          device_id: alert.device_id,
          alert_type: alert.alert_type,
          priority: alert.priority,
          status: alert.status,
          history
        }
      });
    } catch (error) {
      console.error('Error fetching alert history:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch alert history'
      });
    }
  });

  // Get all videos for alert (pre-event, post-event, camera SD)
  router.get('/alerts/:id/videos', async (req, res) => {
    const { id } = req.params;

    try {
      const db = require('../storage/database');

      // Get alert with metadata
      const alertResult = await db.query(
        `SELECT id, device_id, channel, alert_type, timestamp, metadata 
         FROM alerts WHERE id = $1`,
        [id]
      );

      if (alertResult.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: `Alert ${id} not found`
        });
      }

      const alert = alertResult.rows[0];

      // Get linked videos from videos table
      const videosResult = await db.query(
        `SELECT id, file_path, storage_url, file_size, start_time, end_time, 
                duration_seconds, video_type, created_at
         FROM videos 
         WHERE alert_id = $1 
         ORDER BY video_type, start_time`,
        [id]
      );

      // Extract video paths from metadata
      const videoClips = alert.metadata?.videoClips || {};

      const minClipSeconds = Math.max(3, Number(process.env.MIN_ALERT_CLIP_SECONDS || 20));
      const preDuration = Number(videoClips.preDuration || 0);
      const postDuration = Number(videoClips.postDuration || 0);
      const hasPreEvent = !!(videoClips.pre || videoClips.preStorageUrl) && preDuration >= minClipSeconds;
      const hasPostEvent = !!(videoClips.post || videoClips.postStorageUrl) && postDuration >= minClipSeconds;
      const hasCameraVideo = !!(
        videoClips.cameraVideo ||
        videoClips.cameraVideoLocalPath ||
        videoClips.cameraPreVideo ||
        videoClips.cameraPreVideoLocalPath ||
        videoClips.cameraPostVideo ||
        videoClips.cameraPostVideoLocalPath
      );
      const preferredSource = (hasPreEvent || hasPostEvent)
        ? 'buffer_pre_post'
        : (hasCameraVideo ? 'camera_sd' : 'none');
      const defaultSource = 'buffer_pre_post';

      res.json({
        success: true,
        alert_id: id,
        device_id: alert.device_id,
        channel: alert.channel,
        alert_type: alert.alert_type,
        timestamp: alert.timestamp,
        media_links: buildAlertMediaLinks(id),
        default_source: defaultSource,
        preferred_source: preferredSource,
        videos: {
          // Primary evidence: frame-by-frame clips from circular buffer
          pre_event: {
            path: videoClips.pre || null,
            url: `/api/alerts/${encodeURIComponent(id)}/video/pre`,
            raw_url: normalizePublicVideoUrl(
              videoClips.preStorageUrl || videoClips.pre,
              `/api/alerts/${encodeURIComponent(id)}/video/pre`
            ),
            frames: videoClips.preFrameCount || 0,
            duration: preDuration,
            description: 'Primary evidence: 30 seconds before alert (frame-by-frame from circular buffer)'
          },
          post_event: {
            path: videoClips.post || null,
            url: `/api/alerts/${encodeURIComponent(id)}/video/post`,
            raw_url: normalizePublicVideoUrl(
              videoClips.postStorageUrl || videoClips.post,
              `/api/alerts/${encodeURIComponent(id)}/video/post`
            ),
            frames: videoClips.postFrameCount || 0,
            duration: postDuration,
            description: 'Primary evidence: 30 seconds after alert (recorded frame-by-frame live)'
          },
          camera_sd: {
            path: videoClips.cameraVideo || null,
            url: `/api/alerts/${encodeURIComponent(id)}/video/camera`,
            raw_url: normalizePublicVideoUrl(
              videoClips.cameraVideo,
              `/api/alerts/${encodeURIComponent(id)}/video/camera`
            ),
            request_url: `/api/alerts/${encodeURIComponent(id)}/request-report-video`,
            description: 'Secondary evidence: retrieved from camera SD card'
          },
          camera_sd_pre: {
            path: videoClips.cameraPreVideo || null,
            raw_url: normalizePublicVideoUrl(
              videoClips.cameraPreVideo,
              `/api/alerts/${encodeURIComponent(id)}/video/camera`
            ),
            description: 'Camera SD pre-incident clip requested automatically on alert'
          },
          camera_sd_post: {
            path: videoClips.cameraPostVideo || null,
            raw_url: normalizePublicVideoUrl(
              videoClips.cameraPostVideo,
              `/api/alerts/${encodeURIComponent(id)}/video/camera`
            ),
            description: 'Camera SD post-incident clip requested automatically on alert'
          },
          // From videos table (database records)
          database_records: videosResult.rows
        },
        total_videos: videosResult.rows.length,
        has_pre_event: hasPreEvent,
        has_post_event: hasPostEvent,
        has_camera_video: hasCameraVideo
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Failed to fetch alert videos'
      });
    }
  });

  // Request camera SD playback window for reporting (default: 30s before alert)
  router.post('/alerts/:id/request-report-video', async (req, res) => {
    const { id } = req.params;
    const lookbackSeconds = Math.max(0, Math.min(600, Number(req.body?.lookbackSeconds ?? 30)));
    const forwardSeconds = Math.max(0, Math.min(600, Number(req.body?.forwardSeconds ?? 0)));
    const queryResources = req.body?.queryResources !== false;
    const requestDownload = req.body?.requestDownload !== false;

    try {
      const alertManager = tcpServer.getAlertManager();
      const inMemoryAlert = alertManager.getAlertById(id);

      let vehicleId: string | undefined = inMemoryAlert?.vehicleId;
      let channel: number = Number(inMemoryAlert?.channel ?? 1);
      let alertTimestamp: Date | undefined = inMemoryAlert?.timestamp ? new Date(inMemoryAlert.timestamp) : undefined;

      if (!vehicleId || Number.isNaN(alertTimestamp?.getTime())) {
        const db = require('../storage/database');
        const dbResult = await db.query(
          `SELECT id, device_id, channel, timestamp
           FROM alerts
           WHERE id = $1`,
          [id]
        );

        if (dbResult.rows.length === 0) {
          return res.status(404).json({
            success: false,
            message: `Alert ${id} not found`
          });
        }

        const row = dbResult.rows[0];
        vehicleId = String(row.device_id);
        channel = Number(row.channel || 1);
        alertTimestamp = new Date(row.timestamp);
      }

      if (!vehicleId || Number.isNaN(alertTimestamp!.getTime())) {
        return res.status(400).json({
          success: false,
          message: 'Alert has invalid vehicle or timestamp'
        });
      }

      const startTime = new Date(alertTimestamp!.getTime() - lookbackSeconds * 1000);
      const endTime = new Date(alertTimestamp!.getTime() + forwardSeconds * 1000);

      const queried = queryResources
        ? tcpServer.queryResourceList(vehicleId, channel, startTime, endTime)
        : false;
      const requested = tcpServer.requestCameraVideo(vehicleId, channel, startTime, endTime);
      const downloadRequested = requestDownload
        ? tcpServer.requestCameraVideoDownload(vehicleId, channel, startTime, endTime)
        : false;
      const manualCaptureJob = requested
        ? buildManualVideoJob(vehicleId, channel, startTime, endTime, { alertId: id })
        : null;

      if (!requested) {
        return res.status(409).json({
          success: false,
          message: `Vehicle ${vehicleId} is not connected; cannot request camera playback`,
          data: {
            alertId: id,
            vehicleId,
            channel,
            alertTimestamp: alertTimestamp!.toISOString(),
            startTime: startTime.toISOString(),
            endTime: endTime.toISOString(),
            lookbackSeconds,
            forwardSeconds,
            queryResources,
            querySent: queried,
            requestSent: false,
            requestDownload,
            downloadRequestSent: false,
            playbackJobId: manualCaptureJob?.id || null,
            playbackJobUrl: manualCaptureJob ? `/api/videos/jobs/${encodeURIComponent(manualCaptureJob.id)}` : null
          }
        });
      }

      res.json({
        success: true,
        message: `Camera report-video request sent for alert ${id}`,
        data: {
          alertId: id,
          vehicleId,
          channel,
          alertTimestamp: alertTimestamp!.toISOString(),
          startTime: startTime.toISOString(),
          endTime: endTime.toISOString(),
          lookbackSeconds,
          forwardSeconds,
          queryResources,
          querySent: queried,
          requestSent: requested,
          requestDownload,
          downloadRequestSent: downloadRequested,
          playbackJobId: manualCaptureJob?.id || null,
          playbackJobUrl: manualCaptureJob ? `/api/videos/jobs/${encodeURIComponent(manualCaptureJob.id)}` : null
        }
      });
    } catch (error: any) {
      res.status(500).json({
        success: false,
        message: 'Failed to request report video',
        error: error?.message
      });
    }
  });

  // TEST: Query resource list (0x9205)
  router.post('/vehicles/:id/test-query-resources', (req, res) => {
    const { id } = req.params;
    const { channel = 1, minutesBack = 5 } = req.body;

    const vehicle = tcpServer.getVehicle(id);
    if (!vehicle || !vehicle.connected) {
      return res.status(404).json({ success: false, message: 'Vehicle not connected' });
    }

    const endTime = new Date();
    const startTime = new Date(endTime.getTime() - minutesBack * 60000);

    const success = tcpServer.queryResourceList(id, channel, startTime, endTime);
    res.json({
      success,
      message: success ? 'Query sent, check logs for 0x1205 response' : 'Failed to send query'
    });
  });

  // Request arbitrary video range from camera for a vehicle/channel
  router.post('/vehicles/:id/request-video', (req, res) => {
    const { id } = req.params;
    const {
      channel = 1,
      startTime,
      endTime,
      mode = 'both',
      queryResources = true,
      recordPlayback = true
    } = req.body || {};

    const vehicle = tcpServer.getVehicle(id);
    if (!vehicle || !vehicle.connected) {
      return res.status(404).json({
        success: false,
        message: `Vehicle ${id} not connected`
      });
    }

    if (!startTime || !endTime) {
      return res.status(400).json({
        success: false,
        message: 'startTime and endTime are required (ISO timestamp)'
      });
    }

    const start = new Date(startTime);
    const end = new Date(endTime);
    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
      return res.status(400).json({
        success: false,
        message: 'Invalid startTime or endTime'
      });
    }

    if (end <= start) {
      return res.status(400).json({
        success: false,
        message: 'endTime must be after startTime'
      });
    }

    const ch = Number(channel) || 1;
    const normalizedMode = String(mode).toLowerCase();
    const wantStream = normalizedMode === 'stream' || normalizedMode === 'both';
    const wantDownload = normalizedMode === 'download' || normalizedMode === 'both';
    if (!wantStream && !wantDownload) {
      return res.status(400).json({
        success: false,
        message: 'mode must be one of: stream, download, both'
      });
    }

    const querySent = queryResources ? tcpServer.queryResourceList(id, ch, start, end) : false;
    const streamRequestSent = wantStream ? tcpServer.requestCameraVideo(id, ch, start, end) : false;
    const downloadRequestSent = wantDownload ? tcpServer.requestCameraVideoDownload(id, ch, start, end) : false;
    const warnings: string[] = [];
    if (wantDownload && !downloadRequestSent) {
      warnings.push('Download request not sent. Configure FTP env vars: ALERT_VIDEO_FTP_HOST/PORT/USER/PASS/PATH');
    }
    let playbackJobId: string | null = null;
    let playbackJobUrl: string | null = null;
    if (recordPlayback && streamRequestSent) {
      const job = buildManualVideoJob(id, ch, start, end);
      playbackJobId = job.id;
      playbackJobUrl = `/api/videos/jobs/${encodeURIComponent(job.id)}`;
    }

    const anySent = streamRequestSent || downloadRequestSent || querySent;
    if (!anySent) {
      return res.status(409).json({
        success: false,
        message: 'No request was sent (check connection/FTP configuration)',
        data: {
          vehicleId: id,
          channel: ch,
          mode: normalizedMode,
          querySent,
          streamRequestSent,
          downloadRequestSent,
          warnings,
          playbackJobId,
          playbackJobUrl
        }
      });
    }

    res.json({
      success: true,
      message: `Video request submitted for ${id} channel ${ch}`,
      data: {
        vehicleId: id,
        channel: ch,
        mode: normalizedMode,
        startTime: start.toISOString(),
        endTime: end.toISOString(),
        querySent,
        streamRequestSent,
        downloadRequestSent,
        warnings,
        playbackJobId,
        playbackJobUrl
      }
    });
  });

  // Query videos in a time range and return selectable clip list
  router.post('/vehicles/:id/videos/search', async (req, res) => {
    const { id } = req.params;
    const {
      channel = 1,
      startTime,
      endTime,
      waitMs = 8000
    } = req.body || {};

    const vehicle = tcpServer.getVehicle(id);
    if (!vehicle || !vehicle.connected) {
      return res.status(404).json({
        success: false,
        message: `Vehicle ${id} not connected`
      });
    }

    if (!startTime || !endTime) {
      return res.status(400).json({
        success: false,
        message: 'startTime and endTime are required (ISO timestamp)'
      });
    }

    const start = new Date(startTime);
    const end = new Date(endTime);
    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime()) || end <= start) {
      return res.status(400).json({
        success: false,
        message: 'Invalid time range'
      });
    }

    const ch = Number(channel) || 1;
    const before = tcpServer.getLatestResourceList(id)?.receivedAt || 0;
    const querySent = tcpServer.queryResourceList(id, ch, start, end);

    const timeoutAt = Date.now() + Math.max(1000, Math.min(15000, Number(waitMs) || 8000));
    while (Date.now() < timeoutAt) {
      const latest = tcpServer.getLatestResourceList(id);
      if (latest && latest.receivedAt > before) break;
      await new Promise((r) => setTimeout(r, 350));
    }

    const latest = tcpServer.getLatestResourceList(id);
    const items = latest?.items || [];
    const filtered = items
      .filter((it) => ch <= 0 || it.channel === ch)
      .map((it, idx) => {
        const itemStart = parseResourceTime(it.startTime);
        const itemEnd = parseResourceTime(it.endTime);
        const overlaps = itemStart && itemEnd
          ? itemStart.getTime() <= end.getTime() && itemEnd.getTime() >= start.getTime()
          : false;
        return {
          id: `${it.channel}-${idx}-${it.startTime}`,
          ...it,
          overlaps
        };
      })
      .filter((it) => it.overlaps);

    res.json({
      success: true,
      message: `Found ${filtered.length} clip(s) in selected range`,
      data: {
        vehicleId: id,
        channel: ch,
        startTime: start.toISOString(),
        endTime: end.toISOString(),
        querySent,
        latestResourceReceivedAt: latest?.receivedAt || null,
        totalListed: items.length,
        clips: filtered
      }
    });
  });

  // Get status of a manual playback capture job
  router.get('/videos/jobs', (req, res) => {
    const vehicleIdFilter = String(req.query.vehicleId || '').trim();
    const channelFilter = Number(req.query.channel || 0);
    const statusFilter = String(req.query.status || '').trim().toLowerCase();

    const jobs = Array.from(manualVideoJobs.values())
      .filter((job) => {
        if (vehicleIdFilter && job.vehicleId !== vehicleIdFilter) return false;
        if (channelFilter > 0 && job.channel !== channelFilter) return false;
        if (statusFilter && job.status !== statusFilter) return false;
        return true;
      })
      .sort((a, b) => {
        const ta = new Date(a.createdAt).getTime();
        const tb = new Date(b.createdAt).getTime();
        return tb - ta;
      });

    res.json({
      success: true,
      data: {
        count: jobs.length,
        jobs
      }
    });
  });

  // Get status of a manual playback capture job
  router.get('/videos/jobs/:id', (req, res) => {
    const { id } = req.params;
    const job = manualVideoJobs.get(id);
    if (!job) {
      return res.status(404).json({
        success: false,
        message: `Job ${id} not found`
      });
    }
    res.json({
      success: true,
      data: job
    });
  });

  // Stream/download generated manual playback file
  router.get('/videos/jobs/:id/file', (req, res) => {
    const { id } = req.params;
    const job = manualVideoJobs.get(id);
    if (!job) {
      return res.status(404).json({ success: false, message: `Job ${id} not found` });
    }
    if (job.status !== 'completed' || !job.outputPath || !fs.existsSync(job.outputPath)) {
      return res.status(404).json({ success: false, message: 'Video file not ready' });
    }
    res.setHeader('Content-Type', 'video/mp4');
    res.sendFile(path.resolve(job.outputPath));
  });

  // TEST: Request playback (0x9201)
  router.post('/vehicles/:id/test-playback', (req, res) => {
    const { id } = req.params;
    const { channel = 1, minutesBack = 1 } = req.body;

    const vehicle = tcpServer.getVehicle(id);
    if (!vehicle || !vehicle.connected) {
      return res.status(404).json({ success: false, message: 'Vehicle not connected' });
    }

    const endTime = new Date();
    const startTime = new Date(endTime.getTime() - minutesBack * 60000);

    const success = tcpServer.requestCameraVideo(id, channel, startTime, endTime);
    res.json({
      success,
      message: success ? 'Playback request sent, check logs for RTP data' : 'Failed to send request'
    });
  });

  // TEST: Simulate alert to test 30s video capture
  router.post('/test/simulate-alert', async (req, res) => {
    const { vehicleId, channel = 1, alertType = 'fatigue', fatigueLevel = 85 } = req.body;

    if (!vehicleId) {
      return res.status(400).json({
        success: false,
        message: 'vehicleId is required. Use a vehicleId that is currently streaming video.'
      });
    }

    const alertManager = tcpServer.getAlertManager();
    const bufferStats = alertManager.getBufferStats();
    const bufferKey = `${vehicleId}_${channel}`;

    if (!bufferStats[bufferKey] || bufferStats[bufferKey].totalFrames === 0) {
      return res.status(400).json({
        success: false,
        message: `No video frames in buffer for ${bufferKey}. Start video streaming first and wait 30s for buffer to fill.`,
        bufferStats
      });
    }

    // Create a simulated location alert
    const simulatedAlert = {
      vehicleId,
      timestamp: new Date(),
      latitude: 0,
      longitude: 0,
      drivingBehavior: {
        fatigue: alertType === 'fatigue',
        phoneCall: alertType === 'phone',
        smoking: alertType === 'smoking',
        custom: 0,
        fatigueLevel: alertType === 'fatigue' ? fatigueLevel : 0
      }
    };

    // Process through alert manager
    await alertManager.processAlert(simulatedAlert as any);

    res.json({
      success: true,
      message: `Alert simulated for ${vehicleId} channel ${channel}. Check recordings/${vehicleId}/alerts/ for video clips.`,
      bufferBefore: bufferStats[bufferKey],
      note: 'Pre-event video saved immediately. Post-event video will be saved in ~35 seconds.'
    });
  });

  // Check buffer status for all streams
  router.get('/buffers/status', (req, res) => {
    const alertManager = tcpServer.getAlertManager();
    const stats = alertManager.getBufferStats();

    const summary = Object.entries(stats).map(([key, value]: [string, any]) => ({
      stream: key,
      frames: value.totalFrames,
      duration: `${value.bufferDuration?.toFixed(1) || 0}s`,
      oldest: value.oldestFrame,
      newest: value.newestFrame,
      isRecordingPostEvent: value.isRecordingPostEvent,
      postEventAlertId: value.postEventAlertId
    }));

    res.json({
      success: true,
      totalBuffers: Object.keys(stats).length,
      data: summary
    });
  });

  // === NEW REQUIREMENTS ENDPOINTS ===

  // Resolve alert with required notes
  router.post('/alerts/:id/resolve-with-notes', async (req, res) => {
    const { id } = req.params;
    const { notes, resolvedBy, ncrDocumentUrl, ncrDocumentName } = req.body;

    if (!notes || notes.trim().length < 10) {
      return res.status(400).json({
        success: false,
        message: 'Resolution notes required (minimum 10 characters)'
      });
    }

    const alertManager = tcpServer.getAlertManager();
    const alertStorage = require('../storage/alertStorageDB');
    const storage = new alertStorage.AlertStorageDB();

    // Resolve in memory if active (best effort), and always persist in DB.
    await alertManager.resolveAlert(id, notes, resolvedBy);
    const success = await storage.resolveWithNcr(id, notes, resolvedBy, ncrDocumentUrl, ncrDocumentName);

    if (success) {
      res.json({
        success: true,
        message: `Alert ${id} resolved with NCR details`,
        data: {
          alertId: id,
          resolved: true,
          closureType: 'ncr',
          ncrDocumentUrl: ncrDocumentUrl || null,
          ncrDocumentName: ncrDocumentName || null
        }
      });
    } else {
      res.status(404).json({
        success: false,
        message: `Alert ${id} not found`
      });
    }
  });

  // Mark alert as false alert
  router.post('/alerts/:id/mark-false', async (req, res) => {
    const { id } = req.params;
    const { reason, markedBy, reasonCode } = req.body;

    if (!reason || reason.trim().length < 10) {
      return res.status(400).json({
        success: false,
        message: 'Reason required (minimum 10 characters)'
      });
    }

    try {
      const alertStorage = require('../storage/alertStorageDB');
      const storage = new alertStorage.AlertStorageDB();
      const success = await storage.markAsFalseAlert(id, reason, markedBy, reasonCode);

      if (!success) {
        return res.status(404).json({
          success: false,
          message: `Alert ${id} not found`
        });
      }

      res.json({
        success: true,
        message: `Alert ${id} marked as false alert`,
        data: {
          alertId: id,
          resolved: true,
          closureType: 'false_alert',
          reasonCode: reasonCode || null
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Failed to mark alert as false'
      });
    }
  });

  // [REMOVED] /alerts/unattended - moved before /alerts/:id
  // [REMOVED] /alerts/by-priority - moved before /alerts/:id

  // Get screenshots for review (auto-refresh endpoint)
  router.get('/screenshots/recent', async (req, res) => {
    const limit = parseInt(req.query.limit as string) || 50;
    const minutes = parseInt(req.query.minutes as string) || 30;
    const alertsOnly = req.query.alertsOnly === 'true';

    try {
      const query = alertsOnly
        ? `SELECT * FROM images WHERE alert_id IS NOT NULL AND timestamp >= NOW() - ($2 || ' minutes')::interval ORDER BY timestamp DESC LIMIT $1`
        : `SELECT * FROM images WHERE timestamp >= NOW() - ($2 || ' minutes')::interval ORDER BY timestamp DESC LIMIT $1`;

      const result = await require('../storage/database').query(query, [limit, minutes]);

      res.json({
        success: true,
        screenshots: result.rows,
        total: result.rows.length,
        count: result.rows.length,
        lastUpdate: new Date()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Failed to fetch screenshots'
      });
    }
  });

  // Executive Dashboard - Analytics
  router.get('/dashboard/executive', async (req, res) => {
    const days = parseInt(req.query.days as string) || 30;

    try {
      const db = require('../storage/database');

      const alertsByPriority = await db.query(
        `SELECT priority, COUNT(*) as count 
         FROM alerts 
         WHERE timestamp > NOW() - INTERVAL '${days} days'
         GROUP BY priority`
      );

      const alertsByType = await db.query(
        `SELECT alert_type, COUNT(*) as count 
         FROM alerts 
         WHERE timestamp > NOW() - INTERVAL '${days} days'
         GROUP BY alert_type
         ORDER BY count DESC
         LIMIT 10`
      );

      const avgResponseTime = await db.query(
        `SELECT AVG(EXTRACT(EPOCH FROM (acknowledged_at - timestamp))) as avg_seconds
         FROM alerts 
         WHERE acknowledged_at IS NOT NULL
         AND timestamp > NOW() - INTERVAL '${days} days'`
      );

      const escalationRate = await db.query(
        `SELECT 
           COUNT(CASE WHEN escalation_level > 0 THEN 1 END)::FLOAT / NULLIF(COUNT(*), 0) * 100 as rate
         FROM alerts
         WHERE timestamp > NOW() - INTERVAL '${days} days'`
      );

      const resolutionRate = await db.query(
        `SELECT 
           COUNT(CASE WHEN status = 'resolved' THEN 1 END)::FLOAT / NULLIF(COUNT(*), 0) * 100 as rate
         FROM alerts
         WHERE timestamp > NOW() - INTERVAL '${days} days'`
      );

      res.json({
        success: true,
        period: `Last ${days} days`,
        data: {
          alertsByPriority: alertsByPriority.rows,
          alertsByType: alertsByType.rows,
          avgResponseTimeSeconds: parseFloat(avgResponseTime.rows[0]?.avg_seconds || 0).toFixed(2),
          escalationRate: parseFloat(escalationRate.rows[0]?.rate || 0).toFixed(2) + '%',
          resolutionRate: parseFloat(resolutionRate.rows[0]?.rate || 0).toFixed(2) + '%'
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Failed to fetch dashboard data'
      });
    }
  });

  // Record speeding event
  router.post('/speeding/record', async (req, res) => {
    const { vehicleId, driverId, speed, speedLimit, latitude, longitude } = req.body;

    if (!vehicleId || !speed || !speedLimit) {
      return res.status(400).json({
        success: false,
        message: 'vehicleId, speed, and speedLimit are required'
      });
    }

    try {
      const eventId = await speedingManager.recordSpeedingEvent(
        vehicleId,
        driverId || null,
        speed,
        speedLimit,
        { latitude: latitude || 0, longitude: longitude || 0 }
      );

      res.json({
        success: true,
        eventId,
        message: 'Speeding event recorded'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Failed to record speeding event'
      });
    }
  });

  // Get driver rating
  router.get('/drivers/:driverId/rating', async (req, res) => {
    const { driverId } = req.params;

    try {
      const result = await require('../storage/database').query(
        `SELECT * FROM drivers WHERE driver_id = $1`,
        [driverId]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({
          success: false,
          message: 'Driver not found'
        });
      }

      res.json({
        success: true,
        data: result.rows[0]
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Failed to fetch driver rating'
      });
    }
  });

  // Get speeding events for driver
  router.get('/drivers/:driverId/speeding-events', async (req, res) => {
    const { driverId } = req.params;
    const days = parseInt(req.query.days as string) || 7;

    try {
      const result = await require('../storage/database').query(
        `SELECT * FROM speeding_events 
         WHERE driver_id = $1 AND timestamp > NOW() - INTERVAL '${days} days'
         ORDER BY timestamp DESC`,
        [driverId]
      );

      res.json({
        success: true,
        period: `Last ${days} days`,
        total: result.rows.length,
        data: result.rows
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Failed to fetch speeding events'
      });
    }
  });

  return router;
}
